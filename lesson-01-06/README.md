# 2進数の計算方法

## 1. 2進数の足し算・引き算

### 2進数の足し算
2進数の足し算は、10進数と同じように桁ごとに計算し、**「1 + 1 = 10」** となる点に注意します。

#### 計算ルール：
|  計算  | 結果 |
|--------|------|
| 0 + 0  | 0    |
| 0 + 1  | 1    |
| 1 + 0  | 1    |
| 1 + 1  | 10 （繰り上がり） |



1 + 1 は 10 になるので、繰り上がることを忘れないようにしましょう。

---

### 2進数の引き算
2進数の引き算は、**「1から0を引けない場合、隣の桁から借りてくる」** という点がポイントです。

#### 計算ルール：
|  計算  | 結果 |
|--------|------|
| 0 - 0  | 0    |
| 1 - 0  | 1    |
| 1 - 1  | 0    |
| 0 - 1  | 1 （借りてくる必要がある） |



---

## 2. 2進数の掛け算・割り算
2進数の掛け算や割り算は、それぞれの値をいったん10進数に変換して計算し、計算結果を再び2進数に戻すことで求められるが、

シフト演算を使うことで、2進数のまま、掛け算や割り算を行うことができる


## 3. シフト演算（Shift 演算）

### **概要**
シフト演算とは、**ビットを左右にずらして掛け算や割り算を行う方法** です。

- **左シフト ( << )** → 2倍、4倍、8倍...
- **右シフト ( >> )** → 1/2、1/4、1/8...

**シフト演算の種類：**
1. **論理シフト**（Logical Shift）：単純にビットを移動し、空いた部分に0を入れる（非負の整数に適用）。
2. **算術シフト**（Arithmetic Shift）：符号ビットを維持しながらビットを移動（負の数にも適用）。

---

### **論理シフト**

#### **左シフト（<<）**
**ビット列をn個分左にずらすと、「元の値 × 2ⁿ」になる。**

| シフト回数 | 結果 |
|------------|------|
| 1回左シフト (`<<1`) | 2倍 |
| 2回左シフト (`<<2`) | 4倍 |
| 3回左シフト (`<<3`) | 8倍 |

#### 例：
00000011 (3) << 1
00000110 (6) → 2倍

00000011 (3) << 2
00001100 (12) → 4倍


---

#### **右シフト（>>）**
**ビット列をn個分右にずらすと、「元の値 ÷ 2ⁿ」になる。**

| シフト回数 | 結果 |
|------------|------|
| 1回右シフト (`>>1`) | 1/2 |
| 2回右シフト (`>>2`) | 1/4 |
| 3回右シフト (`>>3`) | 1/8 |



### **論理シフトは必ず習得しよう**
シフト演算に関する問題の多くは **論理シフト** だけで解答できます。  
特に **「正の整数」や「非負」というキーワード** がある場合、論理シフトが使われることが多いです。

シフト演算は **高速な計算** に用いられるため、理解しておくと便利です！

---


# 算術シフト（Arithmetic Shift）

## **概要**
算術シフトは、**符号（正負）を考慮するシフト演算** です。  
通常、負の数を扱う場合に使用され、符号ビット（最上位ビット）を維持しながらビット列を移動させます。

---

## **算術シフトのルール**

1. **左シフト（<<）**  
   - 空いたビットには **0を入れる**  
   - 値は **2倍、4倍、8倍...** になる（論理シフトと同じ）
   - **符号ビットは変わる可能性がある**

2. **右シフト（>>）**  
   - 符号ビットを維持する（符号拡張）  
   - 空いたビットには **符号ビットと同じ値（0または1）を入れる**  
   - 値は **1/2、1/4、1/8...** になる（負の数の扱いが異なる）

---
